<!-- /kadie-ai/nodes-docs.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Kadie AI • Nodes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <link rel="stylesheet" href="/assets/main.css" />
  <style>
    :root{ --pad:14px; }
    html,body{height:100%;margin:0;background:#0b0b0c}
    .wrap{display:grid;grid-template-columns:300px 1fr;gap:16px;max-width:1400px;margin:0 auto;padding:var(--pad)}
    /* left menu */
    .menu{background:#0c0f16;border:1px solid #1e2230;border-radius:12px;padding:10px;height:calc(100dvh - 2*var(--pad))}
    .menu h2{margin:6px 8px 10px 8px;font-size:14px}
    .search{display:flex;gap:8px;margin:0 8px 10px 8px;position:sticky;top:0;background:#0c0f16;padding-bottom:8px}
    .search input{flex:1;border:1px solid #2b2f3a;background:#11131a;color:#eaeaea;border-radius:8px;padding:6px 8px}
    .cats{overflow:auto;height:calc(100% - 72px);padding:0 4px}
    details{border-bottom:1px solid #141824}
    details:last-child{border-bottom:0}
    summary{cursor:pointer;padding:8px 6px;color:#cbd5e1;font-weight:600}
    .cat-body{padding:4px 6px 10px 10px}
    .item{padding:6px 8px;border-radius:8px;cursor:pointer}
    .item:hover,.item.active{background:#0f1422}
    .item small{display:block;color:#9aa4b2;font-size:11px}
    /* right pane */
    .desc{background:#0c0f16;border:1px solid #1e2230;border-radius:12px;padding:10px;margin-bottom:12px}
    .view{position:relative;background:#0c0f16;border:1px solid #1e2230;border-radius:12px;min-height:520px;overflow:hidden}
    /* canvas */
    #stage{position:relative;min-height:520px}
    #wires{position:absolute;inset:0;pointer-events:none}
    .legend{position:absolute;right:12px;bottom:12px;background:#0b0c10;border:1px solid #1e2230;border-radius:10px;padding:6px 8px;font-size:12px;color:#cbd5e1}
    .legend span{display:inline-flex;align-items:center;gap:6px;margin-left:10px}
    .legend i{width:12px;height:4px;display:inline-block;background:#ffffff;border-radius:2px}
    .legend i.data{background:#94a3b8}
  </style>
</head>
<body>
  <div class="wrap">
    <aside class="menu" aria-label="Nodes">
      <h2>Nodes</h2>
      <div class="search"><input id="q" type="search" placeholder="Search nodes…"></div>
      <div id="cats" class="cats" aria-live="polite"></div>
    </aside>

    <main aria-live="polite">
      <section class="desc">
        <h3 id="d-name" style="margin:0 0 6px 0">Select a node</h3>
        <p id="d-summary" style="margin:0;color:#9aa4b2">This preview uses the universal node element from the editor.</p>
      </section>

      <section class="view">
        <div id="stage">
          <!-- exact editor node element goes here -->
          <svg id="wires" viewBox="0 0 1000 600" preserveAspectRatio="none"></svg>
        </div>
        <div class="legend">Legend
          <span><i></i> exec</span>
          <span><i class="data"></i> data</span>
        </div>
      </section>
    </main>
  </div>

  <script type="module">
    // Global builder and styles from editor
    import { buildNodeDOM } from '/kadie-ai/blueprints-editor-src/render.node.js';
    import '/kadie-ai/blueprints-editor-src/render.types.js';
    import { fetchNodesIndex } from '/kadie-ai/blueprints-editor-src/nodes-index.js';

    // ------- helpers: categories and UI -------
    const catsEl = document.getElementById('cats');
    const qEl = document.getElementById('q');
    const dName = document.getElementById('d-name');
    const dSummary = document.getElementById('d-summary');
    const stage = document.getElementById('stage');
    const wires = document.getElementById('wires');

    function catPath(def){
      if (Array.isArray(def.categoryPath) && def.categoryPath.length) return def.categoryPath;
      const raw = String(def.category||'').trim();
      return raw ? raw.replace(/[.\\]/g,'/').split('/').filter(Boolean) : ['uncategorized'];
    }
    function treeify(nodes){
      const root={folders:new Map(),items:[]};
      for(const d of nodes){
        const parts=catPath(d);
        let cur=root;
        for(const p of parts){
          if(!cur.folders.has(p)) cur.folders.set(p,{label:p,folders:new Map(),items:[]});
          cur=cur.folders.get(p);
        }
        cur.items.push(d);
      }
      return root;
    }

    function buildMenu(nodes){
      catsEl.innerHTML='';
      const root = treeify(nodes);
      for (const [label, folder] of root.folders){
        const det=document.createElement('details');
        const sum=document.createElement('summary'); sum.textContent=label;
        const body=document.createElement('div'); body.className='cat-body';
        det.appendChild(sum); det.appendChild(body);

        folder.items.sort((a,b)=> (a.name||a.id).localeCompare(b.name||b.id));
        for(const def of folder.items){
          const row=document.createElement('div'); row.className='item'; row.tabIndex=0;
          row.innerHTML = `<div>${def.name||def.id}</div><small>${def.id}</small>`;
          row.addEventListener('click',()=>{ document.querySelectorAll('.item').forEach(x=>x.classList.remove('active')); row.classList.add('active'); renderPreview(def); });
          body.appendChild(row);
        }
        catsEl.appendChild(det);
      }

      qEl.addEventListener('input', ()=>{
        const q = qEl.value.trim().toLowerCase();
        catsEl.querySelectorAll('.item').forEach(el=>{
          const txt = el.textContent.toLowerCase();
          el.style.display = txt.includes(q) ? '' : 'none';
        });
      });
    }

    // ------- preview using the ACTUAL node element -------
    let currentNodeEl = null;

    function clearStage(){
      if (currentNodeEl) { currentNodeEl.remove(); currentNodeEl=null; }
      wires.innerHTML='';
    }

    function centerNode(el){
      const sr = stage.getBoundingClientRect();
      const nr = el.getBoundingClientRect();
      const dx = Math.max(16, (sr.width - nr.width)/2);
      const dy = Math.max(16, (sr.height - nr.height)/2);
      el.style.position = 'absolute';
      el.style.transform = `translate(${dx}px, ${dy}px)`;
    }

    function pinCenters(nodeEl){
      const nr = nodeEl.getBoundingClientRect();
      const get = (sel)=>[...nodeEl.querySelectorAll(sel)].map(j=>{
        const r=j.getBoundingClientRect();
        return { x: r.left - nr.left + r.width/2, y: r.top - nr.top + r.height/2, el: j };
      });
      return {
        left:  get('.pin.left  .jack'),
        right: get('.pin.right .jack'),
        bbox:  nr
      };
    }

    function bez(x1,y1,x2,y2){
      const dx = Math.max(60, Math.abs(x2-x1)*0.5);
      const c1x = x1 + dx, c1y = y1;
      const c2x = x2 - dx, c2y = y2;
      return `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
    }

    function drawWires(def, nodeEl){
      wires.innerHTML='';
      const { left, right } = pinCenters(nodeEl);

      const byName = (arr, side)=> name => {
        const i = (side==='l'? left : right).findIndex(p => p.el.closest('.pin').dataset.pin === name);
        return i >= 0 ? (side==='l'? left[i] : right[i]) : null;
      };
      const L = byName(left,'l'), R = byName(right,'r');

      const map = def?.docs?.pins || {};
      const svgR = wires.getBoundingClientRect();
      const nodeR = nodeEl.getBoundingClientRect();
      const sx = svgR.width / nodeR.width;
      const sy = svgR.height / nodeR.height;

      const toSvg = (p)=>({ x:(p.x)*sx, y:(p.y)*sy });

      for (const [inName, outs] of Object.entries(map)){
        const a = L(inName); if (!a) continue;
        const A = toSvg(a);
        for (const outName of outs){
          const b = R(outName); if (!b) continue;
          const B = toSvg(b);
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          path.setAttribute('class','wire');
          path.setAttribute('d', bez(A.x, A.y, B.x, B.y));
          path.style.stroke = '#94a3b8';
          path.style.strokeWidth = '2';
          path.style.fill = 'none';
          wires.appendChild(path);
        }
      }
    }

    function renderPreview(def){
      clearStage();

      // Build exact node element (GLOBAL)
      currentNodeEl = buildNodeDOM(def, { preview: true, params: {} });
      stage.appendChild(currentNodeEl);
      centerNode(currentNodeEl);
      // text
      dName.textContent = def.name || def.id || 'Node';
      dSummary.textContent = def.docs?.summary || def.discord?.docs || def.discord?.note || '';

      // wires
      drawWires(def, currentNodeEl);
    }

    // ------- load index and boot -------
    const idx = await fetchNodesIndex();
    const nodes = Array.isArray(idx?.nodes) ? idx.nodes : [];
    buildMenu(nodes);
    if (nodes[0]) renderPreview(nodes[0]);
  </script>
</body>
</html>
