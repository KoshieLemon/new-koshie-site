<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Kadie AI • Node Diagram</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <script>
    window.KADIE_HEADER = { title: "Node Diagram", description: "Interactive diagram and documentation for Kadie nodes." };
  </script>
  <script src="/header.mount.js" defer></script>
  <link rel="stylesheet" href="/assets/main.css" />
  <style>
    :root{ --pad:14px; --bg:#0c0f16; --bd:#1e2230; --fg:#e5e7eb; --mut:#9aa4b2; }

    html,body{height:100%;margin:0;background:#0b0b0c;color:var(--fg)}

    /* layout */
    .wrap{
      display:grid;
      grid-template-columns:300px 1fr;
      gap:16px;
      max-width:1600px;
      margin:0 auto;
      padding:var(--pad);
      height:calc(72dvh - 2*var(--pad)); /* fixed height -> no page growth */
      align-items:stretch;
      min-height:0;
    }

    /* left menu */
    .menu{
      background:var(--bg);
      border:1px solid var(--bd);
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden;        /* confine internal scroll */
    }
    .menu h2{margin:6px 8px 10px 8px;font-size:14px}
    .search{
      display:flex;gap:8px;margin:0 8px 10px 8px;
      position:sticky;top:0;background:var(--bg);padding-bottom:8px;z-index:2
    }
    .search input{flex:1;border:1px solid #2b2f3a;background:#11131a;color:#eaeaea;border-radius:8px;padding:6px 8px}
    .cats{
      overflow:auto;          /* scrolls here instead of expanding page */
      flex:1 1 auto;
      min-height:0;
      padding:0 4px
    }
    details{border-bottom:1px solid #141824}
    details:last-child{border-bottom:0}
    summary{cursor:pointer;padding:8px 6px;color:#cbd5e1;font-weight:600;user-select:none;outline:none}
    .cat-body{padding:4px 6px 10px 10px}
    .item{padding:6px 8px;border-radius:8px;cursor:pointer}
    .item:hover,.item.active{background:#0f1422}
    .item small{display:block;color:#9aa4b2;font-size:11px}

    /* right column uses two rows: desc then view that fills */
    main{
      display:grid;
      grid-template-rows:auto 1fr;
      min-height:0;
      overflow:hidden;        /* keep column height fixed */
    }

    /* header info */
    .desc{
      background:var(--bg);
      border:1px solid var(--bd);
      border-radius:12px;
      padding:10px;
      margin-bottom:12px
    }

    /* diagram panel */
    .view{
      position:relative;
      display:flex;
      flex-direction:column;
      gap:6px;
      background:var(--bg);
      border:1px solid var(--bd);
      border-radius:12px;
      padding:10px;
      overflow:hidden;
      min-height:0;
    }
    #stage{
      position:relative;
      flex:1 1 auto;
      min-height:220px;       /* shorter diagram area */
    }
    #wires{position:absolute;inset:0;pointer-events:none;z-index:1}
    #labels{position:absolute;inset:0;pointer-events:none;z-index:2}

    /* pin descriptions */
    .descLabel{
      position:absolute;max-width:360px;color:#ffffff;font-size:12px;line-height:1.28;
      letter-spacing:.1px;pointer-events:none;white-space:normal;text-shadow:0 1px 1px rgba(0,0,0,.45);
    }
    .descLabel.left{text-align:right}

    /* centered description: sibling of #stage */
    #inline-desc{
      margin-top:6px;
      color:#cfd6de;font-size:12px;line-height:1.3;
      max-width:720px;
      align-self:center;
      text-align:center;
      user-select:text;
    }

    .hidden{display:none}
  </style>
</head>
<body data-kadie-header-title="Node Diagram" data-kadie-header-desc="Interactive diagram and documentation for Kadie nodes.">
  <div class="wrap">
    <aside class="menu" aria-label="Nodes">
      <h2>Nodes</h2>
      <div class="search"><input id="q" type="search" placeholder="Search nodes…"></div>
      <div id="cats" class="cats" aria-live="polite"></div>
    </aside>

    <main aria-live="polite">
      <section class="desc">
        <h3 id="d-name" style="margin:0 0 6px 0">Select a node</h3>
        <p id="d-summary" style="margin:0;color:var(--mut)"></p>
      </section>

      <section class="view">
        <div id="stage">
          <svg id="wires" preserveAspectRatio="none"><defs></defs></svg>
          <div id="labels"></div>
        </div>
        <div id="inline-desc" class="hidden"></div>
      </section>
    </main>
  </div>

  <script type="module">
    import { buildNodeDOM } from '/kadie-ai/blueprints-editor-src/render/render.node.js';
    import '/kadie-ai/blueprints-editor-src/render/render.types.js';
    import { fetchNodesIndex } from '/kadie-ai/blueprints-editor-src/providers/nodes-index.js';

    const catsEl=document.getElementById('cats');
    const qEl=document.getElementById('q');
    const dName=document.getElementById('d-name');
    const dSummary=document.getElementById('d-summary');
    const stage=document.getElementById('stage');
    const wires=document.getElementById('wires');
    const labels=document.getElementById('labels');
    const inlineDesc=document.getElementById('inline-desc');

    const sr=el=>el.getBoundingClientRect();
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

    const rowById=new Map();
    let nodes=[];

    function catPath(def){
      if(Array.isArray(def.categoryPath)&&def.categoryPath.length) return def.categoryPath;
      const raw=String(def.category||'').trim();
      return raw?raw.replace(/[.\\]/g,'/').split('/').filter(Boolean):['uncategorized'];
    }
    function treeify(arr){
      const root={label:'root',folders:new Map(),items:[]};
      for(const d of arr){ const parts=catPath(d); let cur=root;
        for(const p of parts){ if(!cur.folders.has(p)) cur.folders.set(p,{label:p,folders:new Map(),items:[]}); cur=cur.folders.get(p); }
        cur.items.push(d);
      } return root;
    }
    function nodeRow(def){
      const row=document.createElement('div');
      row.className='item'; row.tabIndex=0;
      const idStr=String(def.id||def.name||'');
      row.dataset.id=idStr;
      row.dataset.search=((def.name||'')+' '+(def.id||'')+' '+(def.tags||[]).join(' ')).toLowerCase();
      row.innerHTML=`<div>${def.name||def.id}</div><small>${def.id}</small>`;
      row.addEventListener('click',()=>{ document.querySelectorAll('.item').forEach(x=>x.classList.remove('active')); row.classList.add('active'); renderPreview(def); });
      rowById.set(idStr,row);
      return row;
    }
    function renderFolder(label,folder){
      const det=document.createElement('details'); const sum=document.createElement('summary'); sum.textContent=label;
      const body=document.createElement('div'); body.className='cat-body';
      folder.items.sort((a,b)=>(a.name||a.id).localeCompare(b.name||b.id));
      for(const def of folder.items) body.appendChild(nodeRow(def));
      const subs=[...folder.folders.entries()].sort((a,b)=>a[0].localeCompare(b[0]));
      for(const [lab,sub] of subs) body.appendChild(renderFolder(lab,sub));
      det.appendChild(sum); det.appendChild(body); if(label.toLowerCase()==='actions') det.open=true; return det;
    }
    function buildMenu(arr){
      catsEl.innerHTML='';
      const root=treeify(arr);
      const folders=[...root.folders.entries()].sort((a,b)=>a[0].localeCompare(b[0]));
      for(const [label,folder] of folders) catsEl.appendChild(renderFolder(label,folder));
      const filter=q=>{
        const s=q.trim().toLowerCase(); const items=[...catsEl.querySelectorAll('.item')];
        for(const el of items) el.style.display=(!s||el.dataset.search.includes(s))?'':'none';
        const ds=[...catsEl.querySelectorAll('details')].reverse();
        for(const d of ds){ const show=d.querySelector('.item:not([style*="display: none"])'); d.style.display=show?'':'none'; d.open=s?!!show:d.open; }
      };
      qEl.addEventListener('input',()=>filter(qEl.value)); filter('');
    }

    let nodeEl=null, nodeDef=null;

    function setViewBox(){ const w=stage.clientWidth||100, h=stage.clientHeight||100; wires.setAttribute('viewBox',`0 0 ${w} ${h}`); }

    function positionNodeTop(el){
      const S=sr(stage), R=sr(el);
      const x=Math.max(16,(S.width-R.width)/2);
      const y=4;
      el.style.position='absolute';
      el.style.transform=`translate(${x}px, ${y}px)`;
    }

    function stagePoint(el){ const S=sr(stage), R=sr(el); return { x:R.left-S.left+R.width/2, y:R.top-S.top+R.height/2 }; }
    function clearStage(){ if(nodeEl){ nodeEl.remove(); nodeEl=null; } wires.innerHTML=''; labels.innerHTML=''; }

    function elbowToBaseline(px,py,bx,by,left=true){
      const off=26;
      const m1x = left ? px-off : px+off;
      return `M ${px} ${py} L ${m1x} ${py} L ${m1x} ${by} L ${bx} ${by}`;
    }
    function drawPath(d, w=1.6){
      const p=document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d',d); p.style.stroke='#ffffff'; p.style.strokeWidth=String(w); p.style.fill='none'; wires.appendChild(p);
    }

    function packVert(items, minY, maxY, spacing){
      items.sort((a,b)=>a.pinY-b.pinY);
      let y=minY;
      for(const it of items){
        const h=it.h;
        const tgt=Math.max(y, it.pinY - h/2);
        it.top = clamp(tgt, minY, maxY - h);
        y = it.top + h + spacing;
      }
    }

    function drawFromIndex(def){
      const ins=(Array.isArray(def.inputs)?def.inputs:[]).filter(p=>typeof p.desc==='string'&&p.desc.trim());
      const outs=(Array.isArray(def.outputs)?def.outputs:[]).filter(p=>typeof p.desc==='string'&&p.desc.trim());
      if(!ins.length && !outs.length) return;

      setViewBox();
      const S=sr(stage);

      const qPins=(side)=>[...nodeEl.querySelectorAll(`.pin.${side}`)].map((p)=>({
        node:p, jack:p.querySelector('.jack')||p, key:(p.dataset?.pin||'').toLowerCase()
      }));
      const leftPins=qPins('left'), rightPins=qPins('right');
      const by=(arr,name)=>arr.find(p=>p.key===String(name||'').toLowerCase());

      const leftItems=[], rightItems=[];
      const seenL=new Set(), seenR=new Set();

      const mk=(pd, side)=>{
        const dom=(side==='left'?by(leftPins,pd.name):by(rightPins,pd.name));
        if(!dom) return;
        const seen=(side==='left'?seenL:seenR);
        if(seen.has(pd.name)) return;
        seen.add(pd.name);

        const pt=stagePoint(dom.jack);
        const el=document.createElement('div');
        el.className=`descLabel ${side}`;
        el.textContent=pd.desc.trim();
        labels.appendChild(el);

        const r=sr(el);
        const w=r.width, h=r.height;
        const gutter=36;
        let leftX;
        if(side==='left'){ leftX = Math.max(6, pt.x - gutter - w); }
        else{ leftX = Math.min(S.width - w - 6, pt.x + gutter); }

        el.style.left = `${leftX}px`;
        el.style.top  = `${pt.y - h/2}px`;

        const item = { el, w, h, leftX, pinX:pt.x, pinY:pt.y, side };
        (side==='left'?leftItems:rightItems).push(item);
      };

      ins.forEach(p=>mk(p,'left'));
      outs.forEach(p=>mk(p,'right'));

      if(leftItems.length===0 && rightItems.length===0) return;

      packVert(leftItems, 8, S.height-8, 8);
      packVert(rightItems,8, S.height-8, 8);

      for(const it of leftItems){
        const r=sr(it.el); const top=it.top; it.el.style.top=`${top}px`;
        const baseY = top + r.height + 3;
        const x1 = it.leftX; const x2 = it.leftX + r.width;
        drawPath(`M ${x1} ${baseY} L ${x2} ${baseY}`, 1.8);
        drawPath(elbowToBaseline(it.pinX, it.pinY, x2, baseY, true), 1.4);
      }
      for(const it of rightItems){
        const r=sr(it.el); const top=it.top; it.el.style.top=`${top}px`;
        const baseY = top + r.height + 3;
        const x1 = it.leftX; const x2 = it.leftX + r.width;
        drawPath(`M ${x1} ${baseY} L ${x2} ${baseY}`, 1.8);
        drawPath(elbowToBaseline(it.pinX, it.pinY, x1, baseY, false), 1.4);
      }
    }

    function setSiblingDesc(text){
      const val = typeof text === 'string' ? text.trim() : '';
      if (!val){ inlineDesc.textContent=''; inlineDesc.classList.add('hidden'); return; }
      inlineDesc.textContent = val;
      inlineDesc.classList.remove('hidden');
    }

    function renderPreview(def){
      clearStage(); nodeDef=def;
      nodeEl=buildNodeDOM(def,{ preview:true, params:{} }); stage.appendChild(nodeEl);
      dName.textContent=def.name || def.id || 'Node';
      dSummary.textContent='';
      positionNodeTop(nodeEl);
      drawFromIndex(def);
      setSiblingDesc(def.description || '');
      setViewBox();
    }

    function selectById(id){
      const target = nodes.find(n=>String(n.id||'').toLowerCase()===String(id||'').toLowerCase()
                             || String(n.name||'').toLowerCase()===String(id||'').toLowerCase());
      if(!target) return;
      document.querySelectorAll('.item').forEach(x=>x.classList.remove('active'));
      const row = rowById.get(String(target.id||target.name||'')); if (row){ row.classList.add('active'); row.scrollIntoView({block:'nearest'}); }
      renderPreview(target);
    }

    function selectFromQuery(){
      const sp = new URLSearchParams(location.search);
      const id = sp.get('node');
      if (id) selectById(id);
    }

    window.addEventListener('resize',()=>{ 
      if(nodeEl&&nodeDef){ 
        positionNodeTop(nodeEl);
        drawFromIndex(nodeDef);
        setViewBox();
      } 
    });

    window.addEventListener('message', (ev)=>{
      const d = ev?.data || {};
      if (d.type === 'kadie:select-node' && d.nodeId){
        selectById(String(d.nodeId));
      }
    });

    const idx=await fetchNodesIndex();
    nodes=Array.isArray(idx?.nodes)?idx.nodes:[];
    buildMenu(nodes);
    if(nodes[0]) renderPreview(nodes[0]);
    selectFromQuery();
  </script>
  <script src="/footer.mount.js" defer></script>
</body>
</html>
